package DSA.DAA.Exam;

import java.util.*;
class MergeSort {
    // Method to merge two halves and store the merged sublist
    public void merge(int[] arr, int left, int mid, int right, List<int[]> sublists) {
        int n1 = mid - left + 1;
        int n2 = right - mid;

        int[] L = new int[n1];
        int[] R = new int[n2];

        System.arraycopy(arr, left, L, 0, n1);
        System.arraycopy(arr, mid + 1, R, 0, n2);

        int i = 0, j = 0;
        int k = left;

        // Merge the temporary arrays
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        // Copy remaining elements of L[] if any
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }

        // Copy remaining elements of R[] if any
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }

        // Store the current merged sublist as a copy for Optimal Merge Pattern
        int[] sublist = Arrays.copyOfRange(arr, left, right + 1);
        sublists.add(sublist);

        // Print the array after each merge pass
        System.out.print("Merge Pass: ");
        printArr(arr, arr.length);
    }

    // Recursive merge sort function
    public void mergeSort(int[] arr, int left, int right, List<int[]> sublists) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            mergeSort(arr, left, mid, sublists);
            mergeSort(arr, mid + 1, right, sublists);
            merge(arr, left, mid, right, sublists);
        }
    }

    public void printArr(int[] arr, int size) {
        for (int i = 0; i < size; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
}

class OptimalMergePatternn {
    public int mergeSublists(List<int[]> sublists) {
        // PriorityQueue to store sublist sums (total value of each sublist)
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        // Add the sum of elements in each sublist to the heap and print the sum of each sublist
        System.out.println("\nSum of each sublist:");
        for (int[] sublist : sublists) {
            int sum = Arrays.stream(sublist).sum();
            System.out.println("Sublist: " + Arrays.toString(sublist) + " | Sum: " + sum);
            minHeap.add(sum);
        }

        int totalMergeCost = 0;
        while (minHeap.size() > 1) {
            // Remove the two smallest sums from the heap (representing the sublists being merged)
            int first = minHeap.poll();
            int second = minHeap.poll();

            // The merge cost is the sum of the values of the two sublists
            int mergeCost = first + second;

            // Print the merge details
            System.out.println("Merging sublists with sum " + first + " and " + second + " with cost: " + mergeCost);

            // Add the merged sublist sum back into the heap
            totalMergeCost += mergeCost;
            minHeap.add(mergeCost);
        }
        return totalMergeCost;
    }
}

public class mergeomp {
    public static void main(String[] args) {
        MergeSort mergeSortObj = new MergeSort();
        OptimalMergePatternn optimalMergeObj = new OptimalMergePatternn();
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter the number of elements: ");
        int n = sc.nextInt();
        int[] arr = new int[n];
        Random rand = new Random();

        // Randomly generate numbers for the array
        for (int i = 0; i < n; i++) {
            arr[i] = rand.nextInt(100);
        }

        System.out.println("\nUnsorted Array: ");
        mergeSortObj.printArr(arr, n);

        // List to store sublists generated after each Merge Sort pass
        List<int[]> sublists = new ArrayList<>();

        // Perform Merge Sort with pass display and sublist storage
        long startTime = System.nanoTime();
        mergeSortObj.mergeSort(arr, 0, n - 1, sublists);
        long endTime = System.nanoTime();
        long executionTime = endTime - startTime;

        System.out.println("\nSorted Array in Ascending Order:");
        mergeSortObj.printArr(arr, n);

        // Display all sublists generated by Merge Sort passes
        System.out.println("\nSublists generated by Merge Sort passes:");
        for (int i = 0; i < sublists.size(); i++) {
            System.out.print("Sublist " + (i + 1) + ": ");
            mergeSortObj.printArr(sublists.get(i), sublists.get(i).length);
        }

        System.out.println("\nApplying Optimal Merge Pattern to the generated sublists:");
        int mergeCost = optimalMergeObj.mergeSublists(sublists);
        System.out.println("The minimum total cost of merging all sublists is: " + mergeCost);

        System.out.println("\nTime Taken for Merge Sort: " + executionTime + " nanoseconds");
    }
}
